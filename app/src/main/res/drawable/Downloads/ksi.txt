The third component of our model of computer programs is that it executes on a computer system under the control of an operating system. This aspect of a computer program is often not emphasized in introductory programming courses; however, from the perspective of writing secure software, it is critical. Excepting dedicated embedded applications, in general, programs do not run in isolation on most computer systems. Rather, they run under the control of an operating system that mediates access to the resources of that system and shares their use between all the currently executing programs

In addition to the code and data for the program, the process includes information provided by the operating system. These include  environment  variables,  which  may  be  used  to  tailor  the  operation  of  the  program, and any command-line arguments specified for the program. All such data should be considered external inputs to the program whose values need validation before use.
Generally  these  systems  have  a  concept  of  multiple  users  on  the  system.  Resources, like files and devices, are owned by a user and have permissions granting access with various rights to different categories of users. From  the  perspective  of  software  security,  programs  need  access to the various resources, such as files and devices, they use. Unless appropriate access is granted, these programs will likely fail. However, excessive levels of access are also dangerous because any bug in the program could then potentially compro-mise more of the system.
There are also concerns when multiple programs access shared resources, such as a common file. This is a generalization of the problem of managing access to shared memory, which we discussed in Section 1 1.3. Many of the same concerns apply, and appropriate synchronization mechanisms are needed.



Safe Temporary File Use
Many programs need to store a temporary copy of data while they are processing the data. A temporary file is commonly used for this purpose. Most operating systems provide well-known locations for placing temporary files and standard functions for naming and creating them. The critical issue with temporary files is that they are unique and not accessed by other processes. In a sense, this is the opposite problem to managing access to a shared file. The most common technique for constructing a temporary filename is to include a value such as the process identifier. As each pro-cess has its own distinct identifier, this should guarantee a unique name. The program generally checks to ensure that the file does not already exist, perhaps left over from a crash of a previous program, then creates the file. This approach suffices from the perspective of reliability but not with respect to security. 
Again the problem is that an attacker does not play by the rules. The attacker could attempt to guess the temporary filename a privileged program will use. The attacker then attempts to create a file with that name in the interval between the program checking the file does not exist and subsequently creating it. This is another example of a race condition, very similar to that when two processes race to access a  shared  file  when  locks  are  not  used.  There  is  a  famous  example,  reported  in  [WHEE03], of some versions of the tripwire file integrity program9 suffering from this bug. The attacker would write a script that made repeated guesses on the tem-porary filename used and create a symbolic link from that name to the password file. Access  to  the  password  file  was  restricted,  so  the  attacker  could  not  write  to  it.  However, the tripwire program runs with root privileges, giving it access to all files on the system. If the attacker succeeds, then tripwire will follow the link and use the password  file  as  its  temporary  file,  destroying  all  user  login  details  and  denying  access to the system until the administrators can replace the password file with a backup copy. This was a very effective and inconvenient denial-of-service attack on the targeted system. This illustrates the importance of securely managing temporary file creation.
Secure temporary file creation and use preferably requires the use of a random temporary filename. The creation of this file should be done using an atomic system primitive, as is done with the creation of a lockfile. This prevents the race condition and hence the potential exploit of this file. The standard C function mkstemp() is suitable; however, the older functions tmpfile(), tmpnam(), and tempnam() are all insecure unless used with care. It is also important that the minimum access is given to this file. In most cases only the effective owner of the program creating this file should have any access. The GNOME Programming Guidelines recommend using the C code shown in Figure 1 1.9 to create a temporary file in a shared directory on Linux and UNIX systems. Although this code calls the insecure tempnam() function, it uses a loop with appropriately restrictive file creation flags to counter its security deficiencies.  Once  the  program  has  finished  using  the  file,  it  must  be  closed  and  unlinked. Perl programmers can use the File::Temp module for secure temporary file creation. Programmers using other languages should consult appropriate references for suitable methods.

When the file is created in a shared temporary directory, the access permissions should specify that only the owner of the temporary file, or the system administrators, should be able to remove it. This is not always the default permission setting, which must be corrected to enable secure use of such files. On Linux and UNIX systems this requires setting the sticky permission bit on the temporary directory.



Interacting with Other Programs
As well as using functionality provided by the operating system and standard library functions, programs may also use functionality and services provided by other programs. Unless care is taken with this interaction, failure to identify assumptions about the size and interpretation of data flowing among different programs can result in security vulnerabilities. The flow of information between pro-grams can be viewed as output from one forming input to the other. Such issues are of particular concern when the program being used was not originally written with this wider use as a design issue and hence did not adequately identify all the security con-cerns that might arise. This occurs particularly with the current trend of providing Web interfaces to programs that users previously ran directly on the server system. While ideally all programs should be designed to manage security concerns and be written defensively, this is not the case in reality. Hence the burden falls on the newer pro-grams, utilizing these older programs, to identify and manage any security issues that may arise.
A further concern relates to protecting the confidentiality and integrity of the data flowing among various programs. When these programs are running on the same computer system, appropriate use of system functionality such as pipes or tempo-rary files provides this protection. If the programs run on different systems, linked by a suitable network connection, then appropriate security mechanisms should be employed by these network connections. Alternatives include the use of IP Security (IPSec), Transport Layer/Secure Socket Layer Security (TLS/SSL), or Secure Shell (SSH) connections. Even when using well regarded, standardized protocols, care is needed to ensure they use strong cryptography, as weaknesses have been found in a number of algorithms and their implementations [SIMP11]. We will discuss some of these alternatives in Chapter 22.Suitable detection and handling of exceptions and errors generated by program interaction is also important from a security perspective. When one process invokes another program as a child process, it should ensure that the program terminates cor-rectly and accept its exit status. It must also catch and process signals resulting from interaction with other programs and the operating system